<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="icon" type="image/x-icon" href="favicon.ico" />
		<link
			rel="stylesheet"
			type="text/css"
			href="./assets/css/nav-styles.css" />
		<link rel="stylesheet" type="text/css" href="./assets/css/styles.css" />

		<link
			rel="stylesheet"
			type="text/css"
			href="./assets/css/font-color-styles.css" />

		<script src="https://code.jquery.com/jquery-3.0.0.min.js"></script>
		<title>Wave Dot Matrix</title>
		<title>Planet on Spacetime Fabric</title>
		<style>
			body {
				margin: 0;
				overflow: hidden;
				background: radial-gradient(
					circle at center,
					#0a0a1a 0%,
					#000000 100%
				);
			}
			canvas {
				display: block;
			}
		</style>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	</head>
	<body>
		<div id="navbar-placeholder"></div>

		<script>
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(
				60,
				window.innerWidth / window.innerHeight,
				0.1,
				2000
			);
			camera.position.set(0, 500, 600);
			camera.lookAt(0, 0, 0);

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			const mmToPx = 96 / 25.4;
			const colSpacing = 5 * mmToPx;
			const rowSpacing = 5 * mmToPx;
			const width = 900;
			const height = 900;
			const cols = Math.floor(width / colSpacing);
			const rows = Math.floor(height / rowSpacing);

			const dots = [];
			const geometry = new THREE.SphereGeometry(2, 8, 8);

			for (let col = 0; col < cols; col++) {
				for (let row = 0; row < rows; row++) {
					const x = col * colSpacing - width / 2 + colSpacing / 2;
					const z = row * rowSpacing - height / 2 + rowSpacing / 2;
					const progress = Math.sqrt(
						Math.pow((col - cols / 2) / cols, 2) +
							Math.pow((row - rows / 2) / rows, 2)
					);

					const r = Math.floor(100 + progress * 100);
					const g = Math.floor(150 - progress * 50);
					const b = Math.floor(255 - progress * 100);

					const color = new THREE.Color(`rgb(${r}, ${g}, ${b})`);
					const material = new THREE.MeshBasicMaterial({ color });
					const dot = new THREE.Mesh(geometry, material);
					dot.position.set(x, 0, z);
					scene.add(dot);
					dots.push({ mesh: dot, col, row, baseX: x, baseZ: z });
				}
			}

			// Create sun in the center
			const sunGeometry = new THREE.SphereGeometry(60, 32, 32);
			const sunMaterial = new THREE.MeshBasicMaterial({
				color: 0xffdd44,
			});
			const sun = new THREE.Mesh(sunGeometry, sunMaterial);
			sun.position.set(0, 60, 0);
			scene.add(sun);

			// Add sun glow effect
			const glowGeometry = new THREE.SphereGeometry(70, 32, 32);
			const glowMaterial = new THREE.MeshBasicMaterial({
				color: 0xffaa00,
				transparent: true,
				opacity: 0.3,
			});
			const sunGlow = new THREE.Mesh(glowGeometry, glowMaterial);
			sunGlow.position.set(0, 60, 0);
			scene.add(sunGlow);

			// Create planet (light blue)
			const planetGeometry = new THREE.SphereGeometry(25, 32, 32);
			const planetMaterial = new THREE.MeshBasicMaterial({
				color: 0x4db8ff,
				wireframe: false,
			});
			const planet = new THREE.Mesh(planetGeometry, planetMaterial);
			scene.add(planet);

			// Create moon
			const moonGeometry = new THREE.SphereGeometry(8, 16, 16);
			const moonMaterial = new THREE.MeshBasicMaterial({
				color: 0xcccccc,
			});
			const moon = new THREE.Mesh(moonGeometry, moonMaterial);
			scene.add(moon);

			// Add subtle grid lines for spacetime effect
			const gridHelper = new THREE.GridHelper(width, 40, 0x2244ff, 0x112244);
			gridHelper.position.y = -5;
			scene.add(gridHelper);

			let time = 0;

			function animate() {
				time += 0.01;

				// Rotate sun
				sun.rotation.y += 0.005;
				sunGlow.rotation.y -= 0.003;

				// Move planet in orbital path around sun
				const orbitRadius = 280;
				const planetX = Math.cos(time * 0.4) * orbitRadius;
				const planetZ = Math.sin(time * 0.4) * orbitRadius;
				const planetY = 45;
				planet.position.set(planetX, planetY, planetZ);

				// Rotate planet to simulate rolling
				planet.rotation.x += 0.02;
				planet.rotation.y += 0.015;

				// Moon orbits around planet
				const moonOrbitRadius = 50;
				const moonOrbitSpeed = 2.5;
				const moonX =
					planetX + Math.cos(time * moonOrbitSpeed) * moonOrbitRadius;
				const moonZ =
					planetZ + Math.sin(time * moonOrbitSpeed) * moonOrbitRadius;
				const moonY = planetY + Math.sin(time * moonOrbitSpeed) * 15;
				moon.position.set(moonX, moonY, moonZ);

				dots.forEach((dot) => {
					// Sun's gravity well (main effect)
					const dxSun = dot.baseX - 0;
					const dzSun = dot.baseZ - 0;
					const distanceToSun = Math.sqrt(dxSun * dxSun + dzSun * dzSun);

					const sunGravityDepth = 180;
					const sunGravityRadius = 400;

					let yOffset = 0;
					if (distanceToSun < sunGravityRadius) {
						const normalizedDist = distanceToSun / sunGravityRadius;
						yOffset =
							-sunGravityDepth *
							Math.exp(-normalizedDist * 2.5) *
							(1 - normalizedDist);
					}

					// Planet's smaller gravity well
					const dxPlanet = dot.baseX - planetX;
					const dzPlanet = dot.baseZ - planetZ;
					const distanceToPlanet = Math.sqrt(
						dxPlanet * dxPlanet + dzPlanet * dzPlanet
					);

					const planetGravityDepth = 40;
					const planetGravityRadius = 120;

					if (distanceToPlanet < planetGravityRadius) {
						const normalizedDist = distanceToPlanet / planetGravityRadius;
						yOffset +=
							-planetGravityDepth *
							Math.exp(-normalizedDist * 4) *
							(1 - normalizedDist);
					}

					// Add subtle wave motion
					const wave = Math.sin(distanceToSun * 0.02 - time * 2) * 2;

					dot.mesh.position.y = yOffset + wave;
				});

				renderer.render(scene, camera);
				requestAnimationFrame(animate);
			}

			animate();

			window.addEventListener("resize", () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});
		</script>
		<script src="./assets/js/script.js"></script>
	</body>
</html>
