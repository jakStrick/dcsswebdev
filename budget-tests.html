<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Budget App Test Suite</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        max-width: 1200px;
        margin: 2rem auto;
        padding: 0 2rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }
      .container {
        background: white;
        border-radius: 1rem;
        padding: 2rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }
      h1 {
        color: #667eea;
        margin-bottom: 2rem;
      }
      .test-section {
        margin-bottom: 2rem;
        padding: 1rem;
        border: 2px solid #e0e0e0;
        border-radius: 0.5rem;
      }
      .test-section h2 {
        color: #764ba2;
        margin-bottom: 1rem;
        font-size: 1.25rem;
      }
      .test-case {
        padding: 0.75rem;
        margin-bottom: 0.5rem;
        border-radius: 0.375rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .test-case.pass {
        background: #d4edda;
        border-left: 4px solid #28a745;
      }
      .test-case.fail {
        background: #f8d7da;
        border-left: 4px solid #dc3545;
      }
      .test-case.running {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
      }
      .test-name {
        font-weight: 600;
      }
      .test-status {
        padding: 0.25rem 0.75rem;
        border-radius: 0.25rem;
        font-weight: 600;
        font-size: 0.875rem;
      }
      .test-status.pass {
        background: #28a745;
        color: white;
      }
      .test-status.fail {
        background: #dc3545;
        color: white;
      }
      .test-status.running {
        background: #ffc107;
        color: #856404;
      }
      .test-details {
        font-size: 0.875rem;
        color: #666;
        margin-top: 0.25rem;
      }
      .summary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1.5rem;
        border-radius: 0.5rem;
        margin-bottom: 2rem;
        display: flex;
        justify-content: space-around;
        text-align: center;
      }
      .summary-item {
        flex: 1;
      }
      .summary-value {
        font-size: 2rem;
        font-weight: 700;
      }
      .summary-label {
        font-size: 0.875rem;
        opacity: 0.9;
      }
      button {
        background: #667eea;
        color: white;
        border: none;
        padding: 0.75rem 2rem;
        border-radius: 0.5rem;
        font-weight: 600;
        cursor: pointer;
        font-size: 1rem;
        margin-right: 1rem;
      }
      button:hover {
        background: #5568d3;
      }
      button.secondary {
        background: #6c757d;
      }
      button.secondary:hover {
        background: #5a6268;
      }
      .error-details {
        background: #fff3cd;
        border: 1px solid #ffc107;
        padding: 0.75rem;
        border-radius: 0.375rem;
        margin-top: 0.5rem;
        font-family: monospace;
        font-size: 0.875rem;
        color: #856404;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üß™ Budget App Test Suite</h1>

      <div class="summary" id="summary">
        <div class="summary-item">
          <div class="summary-value" id="totalTests">0</div>
          <div class="summary-label">Total Tests</div>
        </div>
        <div class="summary-item">
          <div class="summary-value" id="passedTests">0</div>
          <div class="summary-label">Passed</div>
        </div>
        <div class="summary-item">
          <div class="summary-value" id="failedTests">0</div>
          <div class="summary-label">Failed</div>
        </div>
        <div class="summary-item">
          <div class="summary-value" id="duration">0ms</div>
          <div class="summary-label">Duration</div>
        </div>
      </div>

      <div style="margin-bottom: 2rem">
        <button onclick="runAllTests()">‚ñ∂Ô∏è Run All Tests</button>
        <button class="secondary" onclick="clearResults()">
          üóëÔ∏è Clear Results
        </button>
      </div>

      <div id="testResults"></div>
    </div>

    <script>
      let testResults = {
        total: 0,
        passed: 0,
        failed: 0,
        tests: [],
      };

      const API_BASE_URL = "/api/budget";
      const USER_ID = "test-user-" + Date.now();

      // Test utility functions
      function assert(condition, message) {
        if (!condition) {
          throw new Error(message || "Assertion failed");
        }
      }

      function assertEquals(actual, expected, message) {
        if (actual !== expected) {
          throw new Error(
            `${
              message || "Values not equal"
            }: expected ${expected}, got ${actual}`
          );
        }
      }

      function assertNotNull(value, message) {
        if (value === null || value === undefined) {
          throw new Error(message || "Value is null or undefined");
        }
      }

      // Mock API helper (uses localStorage as fallback for testing)
      async function testSaveBudgetData(type, data) {
        try {
          const response = await fetch(API_BASE_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ userId: USER_ID, type, data }),
          });
          const result = await response.json();
          if (!result.success) {
            throw new Error(result.error);
          }
          return true;
        } catch (error) {
          // Fallback to localStorage for offline testing
          localStorage.setItem(`test_${type}_${USER_ID}`, JSON.stringify(data));
          return true;
        }
      }

      async function testFetchBudgetData() {
        try {
          const response = await fetch(`${API_BASE_URL}?userId=${USER_ID}`);
          const result = await response.json();
          if (result.success) {
            return result.data;
          }
          throw new Error(result.error);
        } catch (error) {
          // Fallback to localStorage
          return {
            settings: {},
            billAdjustments: JSON.parse(
              localStorage.getItem(`test_billAdjustments_${USER_ID}`) || "{}"
            ),
            paymentStatuses: JSON.parse(
              localStorage.getItem(`test_paymentStatus_${USER_ID}`) || "{}"
            ),
            miscExpenses: JSON.parse(
              localStorage.getItem(`test_miscExpense_${USER_ID}`) || "{}"
            ),
            surplusSavings: parseFloat(
              localStorage.getItem(`test_surplusSavings_${USER_ID}`) || "0"
            ),
            bankBalance: localStorage.getItem(`test_bankBalance_${USER_ID}`),
            deposits: JSON.parse(
              localStorage.getItem(`test_deposit_${USER_ID}`) || "{}"
            ),
            customBills: [],
          };
        }
      }

      // Test Cases
      const tests = [
        {
          name: "Bank Balance Persistence",
          section: "Data Persistence",
          async run() {
            const testBalance = "2500.50";
            await testSaveBudgetData("bankBalance", { value: testBalance });
            await new Promise((resolve) => setTimeout(resolve, 100));
            const data = await testFetchBudgetData();
            assertEquals(
              data.bankBalance,
              testBalance,
              "Bank balance should persist"
            );
          },
        },
        {
          name: "Bill Adjustments Save/Load",
          section: "Data Persistence",
          async run() {
            const adjustments = {
              "Test Bill": 150.0,
              "Another Bill": 75.5,
            };
            await testSaveBudgetData("billAdjustments", adjustments);
            await new Promise((resolve) => setTimeout(resolve, 100));
            const data = await testFetchBudgetData();
            assertEquals(
              data.billAdjustments["Test Bill"],
              150.0,
              "Bill adjustment should persist"
            );
          },
        },
        {
          name: "Payment Status Save/Load",
          section: "Data Persistence",
          async run() {
            const statusData = {
              year: 2025,
              month: 11,
              billName: "Test Bill",
              status: "PCL",
            };
            await testSaveBudgetData("paymentStatus", statusData);
            await new Promise((resolve) => setTimeout(resolve, 100));
            const data = await testFetchBudgetData();
            const key = `${statusData.year}-${statusData.month}-${statusData.billName}`;
            assertEquals(
              data.paymentStatuses[key],
              "PCL",
              "Payment status should persist"
            );
          },
        },
        {
          name: "Payment Status REMOVE",
          section: "Payment Status",
          async run() {
            const statusData = {
              year: 2025,
              month: 11,
              billName: "Hidden Bill",
              status: "REMOVE",
            };
            await testSaveBudgetData("paymentStatus", statusData);
            await new Promise((resolve) => setTimeout(resolve, 100));
            const data = await testFetchBudgetData();
            const key = `${statusData.year}-${statusData.month}-${statusData.billName}`;
            assertEquals(
              data.paymentStatuses[key],
              "REMOVE",
              "REMOVE status should persist"
            );
          },
        },
        {
          name: "Misc Expense Save/Load",
          section: "Data Persistence",
          async run() {
            const miscData = {
              year: 2025,
              month: 11,
              paycheckIndex: 0,
              data: {
                total: 150.0,
                entries: [
                  {
                    amount: 50,
                    comment: "Gas",
                    timestamp: new Date().toISOString(),
                  },
                  {
                    amount: 100,
                    comment: "Groceries",
                    timestamp: new Date().toISOString(),
                  },
                ],
              },
            };
            await testSaveBudgetData("miscExpense", miscData);
            await new Promise((resolve) => setTimeout(resolve, 100));
            const data = await testFetchBudgetData();
            const key = `${miscData.year}-${miscData.month}-Misc-${miscData.paycheckIndex}`;
            assertNotNull(data.miscExpenses[key], "Misc expense should exist");
          },
        },
        {
          name: "Surplus Savings Save/Load",
          section: "Data Persistence",
          async run() {
            await testSaveBudgetData("surplusSavings", { amount: 5000.0 });
            await new Promise((resolve) => setTimeout(resolve, 100));
            const data = await testFetchBudgetData();
            assertEquals(
              data.surplusSavings,
              5000.0,
              "Surplus savings should persist"
            );
          },
        },
        {
          name: "Deposit Save/Load",
          section: "Data Persistence",
          async run() {
            const depositData = {
              year: 2025,
              month: 11,
              data: {
                total: 500.0,
                entries: [
                  {
                    amount: 500,
                    comment: "Cash tip",
                    timestamp: new Date().toISOString(),
                  },
                ],
              },
            };
            await testSaveBudgetData("deposit", depositData);
            await new Promise((resolve) => setTimeout(resolve, 100));
            const data = await testFetchBudgetData();
            const key = `${depositData.year}-${depositData.month}`;
            assertNotNull(data.deposits[key], "Deposit should exist");
          },
        },
        {
          name: "Multiple Status Changes",
          section: "Payment Status",
          async run() {
            const bill = { year: 2025, month: 11, billName: "Status Test" };

            // NP -> PNC
            await testSaveBudgetData("paymentStatus", {
              ...bill,
              status: "PNC",
            });
            await new Promise((resolve) => setTimeout(resolve, 50));
            let data = await testFetchBudgetData();
            let key = `${bill.year}-${bill.month}-${bill.billName}`;
            assertEquals(
              data.paymentStatuses[key],
              "PNC",
              "Status should be PNC"
            );

            // PNC -> PCL
            await testSaveBudgetData("paymentStatus", {
              ...bill,
              status: "PCL",
            });
            await new Promise((resolve) => setTimeout(resolve, 50));
            data = await testFetchBudgetData();
            assertEquals(
              data.paymentStatuses[key],
              "PCL",
              "Status should be PCL"
            );

            // PCL -> REMOVE
            await testSaveBudgetData("paymentStatus", {
              ...bill,
              status: "REMOVE",
            });
            await new Promise((resolve) => setTimeout(resolve, 50));
            data = await testFetchBudgetData();
            assertEquals(
              data.paymentStatuses[key],
              "REMOVE",
              "Status should be REMOVE"
            );
          },
        },
        {
          name: "Misc Expense Accumulation",
          section: "Calculations",
          async run() {
            const miscKey = { year: 2025, month: 11, paycheckIndex: 0 };

            // First expense
            await testSaveBudgetData("miscExpense", {
              ...miscKey,
              data: {
                total: 50,
                entries: [
                  {
                    amount: 50,
                    comment: "First",
                    timestamp: new Date().toISOString(),
                  },
                ],
              },
            });

            // Second expense
            await testSaveBudgetData("miscExpense", {
              ...miscKey,
              data: {
                total: 125,
                entries: [
                  {
                    amount: 50,
                    comment: "First",
                    timestamp: new Date().toISOString(),
                  },
                  {
                    amount: 75,
                    comment: "Second",
                    timestamp: new Date().toISOString(),
                  },
                ],
              },
            });

            const data = await testFetchBudgetData();
            const key = `${miscKey.year}-${miscKey.month}-Misc-${miscKey.paycheckIndex}`;
            const miscData = data.miscExpenses[key];
            assertEquals(miscData.total, 125, "Total should accumulate");
            assertEquals(miscData.entries.length, 2, "Should have 2 entries");
          },
        },
        {
          name: "Data Isolation Between Months",
          section: "Data Integrity",
          async run() {
            // Save data for November
            await testSaveBudgetData("paymentStatus", {
              year: 2025,
              month: 11,
              billName: "Test Bill",
              status: "PCL",
            });

            // Save different data for December
            await testSaveBudgetData("paymentStatus", {
              year: 2025,
              month: 12,
              billName: "Test Bill",
              status: "NP",
            });

            const data = await testFetchBudgetData();
            const novKey = "2025-11-Test Bill";
            const decKey = "2025-12-Test Bill";

            assertEquals(
              data.paymentStatuses[novKey],
              "PCL",
              "November status should be PCL"
            );
            assertEquals(
              data.paymentStatuses[decKey],
              "NP",
              "December status should be NP"
            );
          },
        },
      ];

      // Test runner
      async function runTest(test) {
        const startTime = performance.now();
        const testElement = document.createElement("div");
        testElement.className = "test-case running";
        testElement.innerHTML = `
                <div>
                    <div class="test-name">${test.name}</div>
                    <div class="test-details">Running...</div>
                </div>
                <span class="test-status running">RUNNING</span>
            `;

        const section = getOrCreateSection(test.section);
        section.appendChild(testElement);

        try {
          await test.run();
          const duration = (performance.now() - startTime).toFixed(2);
          testElement.className = "test-case pass";
          testElement.innerHTML = `
                    <div>
                        <div class="test-name">‚úì ${test.name}</div>
                        <div class="test-details">Completed in ${duration}ms</div>
                    </div>
                    <span class="test-status pass">PASS</span>
                `;
          testResults.passed++;
          return { passed: true, duration };
        } catch (error) {
          const duration = (performance.now() - startTime).toFixed(2);
          testElement.className = "test-case fail";
          testElement.innerHTML = `
                    <div style="flex: 1;">
                        <div class="test-name">‚úó ${test.name}</div>
                        <div class="test-details">Failed after ${duration}ms</div>
                        <div class="error-details">${error.message}</div>
                    </div>
                    <span class="test-status fail">FAIL</span>
                `;
          testResults.failed++;
          return { passed: false, duration, error: error.message };
        }
      }

      function getOrCreateSection(sectionName) {
        let section = document.getElementById(
          `section-${sectionName.replace(/\s+/g, "-")}`
        );
        if (!section) {
          section = document.createElement("div");
          section.className = "test-section";
          section.id = `section-${sectionName.replace(/\s+/g, "-")}`;
          section.innerHTML = `<h2>${sectionName}</h2>`;
          document.getElementById("testResults").appendChild(section);
        }
        return section;
      }

      async function runAllTests() {
        testResults = { total: tests.length, passed: 0, failed: 0, tests: [] };
        document.getElementById("testResults").innerHTML = "";

        const startTime = performance.now();

        for (const test of tests) {
          const result = await runTest(test);
          testResults.tests.push({ name: test.name, ...result });
        }

        const totalDuration = (performance.now() - startTime).toFixed(2);

        // Update summary
        document.getElementById("totalTests").textContent = testResults.total;
        document.getElementById("passedTests").textContent = testResults.passed;
        document.getElementById("failedTests").textContent = testResults.failed;
        document.getElementById("duration").textContent = totalDuration + "ms";

        console.log("Test Results:", testResults);
      }

      function clearResults() {
        document.getElementById("testResults").innerHTML = "";
        testResults = { total: 0, passed: 0, failed: 0, tests: [] };
        document.getElementById("totalTests").textContent = "0";
        document.getElementById("passedTests").textContent = "0";
        document.getElementById("failedTests").textContent = "0";
        document.getElementById("duration").textContent = "0ms";

        // Clean up test data
        Object.keys(localStorage).forEach((key) => {
          if (key.startsWith("test_")) {
            localStorage.removeItem(key);
          }
        });
      }
    </script>
  </body>
</html>
